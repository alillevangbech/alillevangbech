#ifndef SPARSE_VECTOR_HPP
#define SPARSE_VECTOR_HPP

#include "Vector.hpp"
#include "Matrix.hpp"
#include <vector>

template<class T>
class SparseVector{
public:
	//creates an empty vector of dimensionality 0.
	SparseVector<T>();
	// Creates a vector of dimensionality dim. It starts with 0 nonzero elements
	// which need to be set using setValue
	SparseVector(unsigned int dim);

	// assignment operators and copy constructor should be automatically
	// generated by the compiler when using a std::vector for internal storing.
	// However, test that assignment works!

	//sets the value v_i of the vector. if it does not exist it is added 
	void setValue(unsigned int index, T value);
	
	//returns the value v_i of the vector. Returns 0 if the value is not stored
	T getValue(unsigned int index)const;
	
	//returns the dimensionality of the vector
	unsigned int size()const;
	
	// returns the number stored elements
	unsigned int nonZeroes()const;

	//returns the index of the ith stored nonzero entry (in increasing order)
	unsigned int indexNonZero(unsigned int i)const;
	//returns the value of the ith stored nonzero entry (in increasing order)
	T valueNonZero(unsigned int i)const;
	
	//adds x too the current vector
	SparseVector<T>& operator+= (SparseVector<T> const& x);
	//subtracts x from the current vector
	SparseVector<T>& operator-= (SparseVector<T> const& x);
private:
	std::vector<unsigned int> mIndice;
	std::vector<T> mValue;
	int mSize;


	//Add your data members here!
};

template <class T>
SparseVector<T>::SparseVector()
{
	mSize = 0;
}

template <class T>
SparseVector<T>::SparseVector(unsigned int dim)
{
	mSize = dim;

}



template <class T>
void SparseVector<T>::setValue(unsigned int index, T value)

{
	std::vector<unsigned int>::iterator low;
	low = std::lower_bound(mIndice.begin(),mIndice.end(), index);
	if (low == mIndice.end()){
	mIndice.push_back(index);
	mValue.push_back(value);
	}
	else if (*low == index)
	{
	mValue[low-mIndice.begin()] = value;
	}
	else
	{
/*	std::vector<T>::iterator _val;
         = mValue.begin();
	std::advance(_val,);*/
	mValue.insert(mValue.begin()+std::distance(mIndice.begin(),low),value);
	mIndice.insert(low,index);
	}
}
	

			


template <class T>
T SparseVector<T>::getValue(unsigned int index) const
{
	std::vector<unsigned int>::const_iterator lower;
	lower = std::lower_bound(mIndice.begin(),mIndice.end(), index);
	if (*lower == index)
	{ 
	return mValue[lower-mIndice.begin()];
	}
	else
	{ 
	return 0;
	}
	
}

template <class T>
unsigned int SparseVector<T>::size() const
{
	return mSize;
}

template <class T>
unsigned int SparseVector<T>::nonZeroes()const
{
	return mValue.size();	
}

template <class T>
unsigned int SparseVector<T>::indexNonZero(unsigned int i) const
{	
	return mIndice[i];
}


template <class T>
T SparseVector<T>::valueNonZero(unsigned int i) const
{
	return mValue[i];
}

template <class T>
SparseVector<T>& SparseVector<T>::operator+= (SparseVector<T> const& x)
{

	std::vector<unsigned int>::const_iterator low,mine;
	mine = x.mIndice.begin();
	for (int i = 0; i < x.mIndice.size(); i++)
	{
		low = std::lower_bound(mIndice.begin(),mIndice.end(), *mine);
		if (low == mIndice.end())
		{
			mValue.push_back(x.mValue[i]);
			mIndice.push_back(x.mIndice[i]);
		}		

		else if (*low == *mine)
		{
			mValue[low - mIndice.begin()] += x.mValue[i];
		}
		
		else
		{
			mValue.insert(mValue.begin()+(mIndice.end() - low),x.mValue[i]);
			mIndice.insert(mIndice.begin()+(mIndice.end() - low),x.mIndice[i]);
		}
	std::advance(mine,1);
			
	}
	
	return *this;
	
}


template <class T>
SparseVector<T>& SparseVector<T>::operator-= (SparseVector<T> const& x)
{

	std::vector<unsigned int>::const_iterator low,mine;
	mine = x.mIndice.begin();
	for (int i = 0; i < x.mIndice.size(); i++)
	{
		low = std::lower_bound(mIndice.begin(),mIndice.end(), *mine);
		if (low == mIndice.end())
		{
			mValue.push_back(-x.mValue[i]);
			mIndice.push_back(x.mIndice[i]);
		}		

		else if (*low == *mine)
		{
			mValue[low - mIndice.begin()] -= x.mValue[i];
		}
		
		else
		{
			mValue.insert(mValue.begin()+(mIndice.end() - low),-x.mValue[i]);
			mIndice.insert(mIndice.begin()+(mIndice.end() - low),x.mIndice[i]);
		}
	std::advance(mine,1);
			
	}
	
	return *this;
	
}






// computes z= x+y, equivalent to z=x, z+=y
template<class T>
SparseVector<T> operator+(SparseVector<T> const& x, SparseVector<T> const& y)
{
	SparseVector<T> z;

	
	z = x;	
	z +=y;
	return z;

}




// computes z= x-y, equivalent to z=x, z-=y
template<class T>
SparseVector<T> operator-(SparseVector<T> const& x, SparseVector<T> const& y)
{
	SparseVector<T> z;

	
	z = x;	
	z -=y;
	return z;

}


// computes the matrix-vector product of a dense matrix and sparse vector z=Ax.
// The result is a dense vector.
template<class T>
Vector<T> operator* (Matrix<T> const& A, SparseVector<T> const& x)
{
	Vector<T> z(x.nonZeroes());
	for (int i = 0; i < x.nonZeroes(); i++)
	{
		for (int j = 0; j < x.size(); i++)
		{
			
			//z[i] += A[x.indexNonZero(i) + j]*x.valueNonZero(i);
			z[i] += A(x.indexNonZero(i),j)*x.valueNonZero(i);
		}	
	}
	return z;
	
}

	
	
	



// computes the matrix-vector product of a dense matrix and sparse vector z=x^TA.
// The result is a dense vector.
template<class T>
Vector<T> operator* (SparseVector<T> const& x, Matrix<T> const& A)
{
	Vector<T> z;
	for (int i = 0; i < x.nonZeroes(); i++)
	{
		for (int j = 0; j < x.size(); i++)
		{
			
			z[i] += A(j,x.indexNonZero(i))*x.valueNonZero(i);
		}
	}
	return z;
	
}





#endif
